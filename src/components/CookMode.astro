---
interface Props {
  steps: string[];
  slug: string;
}

const { steps, slug } = Astro.props;
---

<div class="cook-mode hidden" data-slug={slug}>
  {/* Cook Mode Overlay */}
  <div class="cook-mode-overlay fixed inset-0 z-50 bg-ctp-base flex flex-col">
    {/* Header */}
    <div
      class="flex items-center justify-between px-6 py-4 border-b border-ctp-surface1"
    >
      <div class="flex items-center gap-3">
        <div
          class="wake-lock-indicator flex items-center gap-2 px-3 py-1.5 rounded-full bg-ctp-surface0 text-sm"
        >
          <span class="wake-lock-dot w-2 h-2 rounded-full bg-ctp-overlay0"
          ></span>
          <span class="wake-lock-text text-ctp-subtext1">Screen: Auto-off</span>
        </div>
      </div>

      <button
        type="button"
        class="exit-cook-mode p-2 rounded-full bg-ctp-surface0 hover:bg-ctp-surface1 transition-colors"
        aria-label="Exit cook mode"
      >
        <svg
          class="w-6 h-6 text-ctp-text"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          stroke-width="2"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>

    {/* Step Content */}
    <div
      class="flex-1 flex flex-col items-center justify-center px-6 py-8 overflow-y-auto"
    >
      <div class="step-progress text-ctp-subtext1 text-lg mb-4">
        Step <span class="step-current">1</span> of <span class="step-total"
          >{steps.length}</span
        >
      </div>

      <div class="step-content max-w-2xl text-center">
        {
          steps.map((step, index) => (
            <div class="step-item hidden" data-step={index}>
              <p class="text-2xl md:text-3xl lg:text-4xl leading-relaxed text-ctp-text font-medium">
                {step}
              </p>
            </div>
          ))
        }
      </div>
    </div>

    {/* Navigation */}
    <div
      class="flex items-center justify-between px-6 py-6 border-t border-ctp-surface1 bg-ctp-mantle"
    >
      <button
        type="button"
        class="step-prev flex items-center gap-2 px-6 py-3 rounded-xl bg-ctp-surface0 hover:bg-ctp-surface1 text-ctp-text transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        aria-label="Previous step"
      >
        <svg
          class="w-5 h-5"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          stroke-width="2"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M15 19l-7-7 7-7"></path>
        </svg>
        <span class="text-lg font-medium">Previous</span>
      </button>

      <div class="step-dots flex gap-2">
        {
          steps.map((_, index) => (
            <button
              type="button"
              class="step-dot w-3 h-3 rounded-full bg-ctp-surface1 transition-colors"
              data-step={index}
              aria-label={`Go to step ${index + 1}`}
            />
          ))
        }
      </div>

      <button
        type="button"
        class="step-next flex items-center gap-2 px-6 py-3 rounded-xl bg-ctp-mauve hover:bg-ctp-mauve/90 text-ctp-base transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        aria-label="Next step"
      >
        <span class="text-lg font-medium">Next</span>
        <svg
          class="w-5 h-5"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          stroke-width="2"
        >
          <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"
          ></path>
        </svg>
      </button>
    </div>
  </div>
</div>

{/* Cook Mode Toggle Button */}
<button
  type="button"
  class="cook-mode-toggle inline-flex items-center gap-2 px-4 py-2 rounded-xl bg-ctp-mauve text-ctp-base font-medium transition-all hover:bg-ctp-mauve/90 hover:scale-105"
  data-slug={slug}
  aria-label="Enter cook mode"
>
  <svg
    class="w-5 h-5"
    fill="none"
    stroke="currentColor"
    viewBox="0 0 24 24"
    stroke-width="2"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
    ></path>
  </svg>
  <span>Cook Mode</span>
</button>

<script>
  interface WakeLockSentinel {
    release(): Promise<void>;
    released: boolean;
    type: 'screen';
    onrelease: ((this: WakeLockSentinel, ev: Event) => void) | null;
  }

  interface WakeLock {
    request(type: 'screen'): Promise<WakeLockSentinel>;
  }

  declare global {
    interface Navigator {
      wakeLock?: WakeLock;
    }
  }

  function initCookMode() {
    const cookModes = document.querySelectorAll('.cook-mode');
    const toggleBtns = document.querySelectorAll('.cook-mode-toggle');

    toggleBtns.forEach((toggleBtn) => {
      const slug = (toggleBtn as HTMLElement).dataset.slug;
      if (!slug) return;

      const cookMode = document.querySelector(
        `.cook-mode[data-slug="${slug}"]`
      );
      if (!cookMode) return;

      const overlay = cookMode.querySelector('.cook-mode-overlay');
      const exitBtn = cookMode.querySelector('.exit-cook-mode');
      const prevBtn = cookMode.querySelector('.step-prev') as HTMLButtonElement;
      const nextBtn = cookMode.querySelector('.step-next') as HTMLButtonElement;
      const stepItems = cookMode.querySelectorAll('.step-item');
      const stepDots = cookMode.querySelectorAll('.step-dot');
      const currentEl = cookMode.querySelector('.step-current');
      const wakeLockDot = cookMode.querySelector('.wake-lock-dot');
      const wakeLockText = cookMode.querySelector('.wake-lock-text');

      const totalSteps = stepItems.length;
      const storageKey = `cook-mode-step-${slug}`;

      // Load saved step or start at 0
      let currentStep = parseInt(localStorage.getItem(storageKey) || '0', 10);
      if (isNaN(currentStep) || currentStep < 0 || currentStep >= totalSteps) {
        currentStep = 0;
      }

      let wakeLock: WakeLockSentinel | null = null;

      function updateStepDisplay() {
        // Update step items visibility
        stepItems.forEach((item, index) => {
          if (index === currentStep) {
            item.classList.remove('hidden');
          } else {
            item.classList.add('hidden');
          }
        });

        // Update step dots
        stepDots.forEach((dot, index) => {
          if (index === currentStep) {
            dot.classList.remove('bg-ctp-surface1');
            dot.classList.add('bg-ctp-mauve');
          } else {
            dot.classList.add('bg-ctp-surface1');
            dot.classList.remove('bg-ctp-mauve');
          }
        });

        // Update step counter
        if (currentEl) {
          currentEl.textContent = String(currentStep + 1);
        }

        // Update button states
        prevBtn.disabled = currentStep === 0;
        nextBtn.disabled = currentStep === totalSteps - 1;

        // Save to localStorage
        localStorage.setItem(storageKey, String(currentStep));
      }

      async function requestWakeLock() {
        if ('wakeLock' in navigator && navigator.wakeLock) {
          try {
            wakeLock = await navigator.wakeLock.request('screen');
            updateWakeLockIndicator(true);

            // Re-request wake lock if it gets released (e.g., page visibility change)
            wakeLock.onrelease = () => {
              updateWakeLockIndicator(false);
            };

            // Re-acquire when page becomes visible again
            document.addEventListener(
              'visibilitychange',
              handleVisibilityChange
            );
          } catch (err) {
            console.log('Wake Lock request failed:', err);
            updateWakeLockIndicator(false);
          }
        } else {
          // Wake Lock not supported
          updateWakeLockIndicator(false, true);
        }
      }

      function handleVisibilityChange() {
        if (
          document.visibilityState === 'visible' &&
          !cookMode.classList.contains('hidden')
        ) {
          requestWakeLock();
        }
      }

      async function releaseWakeLock() {
        if (wakeLock && !wakeLock.released) {
          await wakeLock.release();
          wakeLock = null;
        }
        document.removeEventListener(
          'visibilitychange',
          handleVisibilityChange
        );
        updateWakeLockIndicator(false);
      }

      function updateWakeLockIndicator(active: boolean, notSupported = false) {
        if (!wakeLockDot || !wakeLockText) return;

        if (notSupported) {
          wakeLockDot.classList.remove('bg-ctp-green', 'bg-ctp-overlay0');
          wakeLockDot.classList.add('bg-ctp-yellow');
          wakeLockText.textContent = 'Wake lock unavailable';
        } else if (active) {
          wakeLockDot.classList.remove('bg-ctp-yellow', 'bg-ctp-overlay0');
          wakeLockDot.classList.add('bg-ctp-green');
          wakeLockText.textContent = 'Screen: Staying on';
        } else {
          wakeLockDot.classList.remove('bg-ctp-green', 'bg-ctp-yellow');
          wakeLockDot.classList.add('bg-ctp-overlay0');
          wakeLockText.textContent = 'Screen: Auto-off';
        }
      }

      function enterCookMode() {
        cookMode.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
        updateStepDisplay();
        requestWakeLock();
      }

      function exitCookMode() {
        cookMode.classList.add('hidden');
        document.body.style.overflow = '';
        releaseWakeLock();
      }

      // Event listeners
      toggleBtn.addEventListener('click', enterCookMode);

      exitBtn?.addEventListener('click', exitCookMode);

      prevBtn.addEventListener('click', () => {
        if (currentStep > 0) {
          currentStep--;
          updateStepDisplay();
        }
      });

      nextBtn.addEventListener('click', () => {
        if (currentStep < totalSteps - 1) {
          currentStep++;
          updateStepDisplay();
        }
      });

      // Step dot navigation
      stepDots.forEach((dot, index) => {
        dot.addEventListener('click', () => {
          currentStep = index;
          updateStepDisplay();
        });
      });

      // Keyboard navigation
      function handleKeyDown(e: KeyboardEvent) {
        if (cookMode.classList.contains('hidden')) return;

        switch (e.key) {
          case 'ArrowLeft':
          case 'ArrowUp':
            if (currentStep > 0) {
              currentStep--;
              updateStepDisplay();
            }
            break;
          case 'ArrowRight':
          case 'ArrowDown':
          case ' ':
            e.preventDefault();
            if (currentStep < totalSteps - 1) {
              currentStep++;
              updateStepDisplay();
            }
            break;
          case 'Escape':
            exitCookMode();
            break;
        }
      }

      document.addEventListener('keydown', handleKeyDown);

      // Initialize display
      updateStepDisplay();
    });
  }

  // Initialize on page load
  initCookMode();

  // Re-initialize when navigating with View Transitions
  document.addEventListener('astro:page-load', initCookMode);
</script>

<style>
  .cook-mode-overlay {
    animation: fadeIn 0.2s ease-out;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  .step-item {
    animation: slideIn 0.3s ease-out;
  }

  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .step-dot {
    transition: all 0.2s ease;
  }

  .step-dot:hover {
    transform: scale(1.2);
  }
</style>
