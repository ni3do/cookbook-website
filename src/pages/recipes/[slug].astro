---
import BaseLayout from '../../layouts/BaseLayout.astro';
import ServingsScaler from '../../components/ServingsScaler.astro';
import { getCollection, type CollectionEntry } from 'astro:content';

// Prerender all recipe pages at build time
export const prerender = true;

// Generate static paths for all recipes
export async function getStaticPaths() {
  const recipes = await getCollection('recipes');
  return recipes.map((recipe) => ({
    params: { slug: recipe.slug },
    props: { recipe },
  }));
}

interface Props {
  recipe: CollectionEntry<'recipes'>;
}

const { recipe } = Astro.props;
const { data, slug } = recipe;
const { title, image, author, prep_time, cook_time, servings, tags, source, notes } = data;

const totalTime = prep_time + cook_time;
const imagePath = `/images/recipes/${image}`;

// Render the markdown content
const { Content, headings } = await recipe.render();

// Parse the raw body to extract ingredients and steps sections
const rawBody = recipe.body;

// Helper to parse markdown content into sections
function parseRecipeContent(content: string) {
  const sections: { type: 'ingredients' | 'steps'; heading: string; items: string[] }[] = [];

  // Split by h2 headings (## Heading)
  const parts = content.split(/^## /m).filter(Boolean);

  for (const part of parts) {
    const lines = part.trim().split('\n');
    const heading = lines[0].trim();
    const body = lines.slice(1).join('\n').trim();

    // Determine if this is ingredients or steps
    const headingLower = heading.toLowerCase();

    if (headingLower === 'steps' || headingLower === 'instructions' || headingLower === 'directions' || headingLower === 'method') {
      // Parse numbered steps
      const stepMatches = body.match(/^\d+\.\s+.+$/gm);
      if (stepMatches) {
        sections.push({
          type: 'steps',
          heading,
          items: stepMatches.map((step) => step.replace(/^\d+\.\s+/, '').trim()),
        });
      }
    } else if (body.includes('- ')) {
      // This is an ingredients section (has bullet points)
      const ingredients = body
        .split('\n')
        .filter((line) => line.trim().startsWith('- '))
        .map((line) => line.replace(/^-\s+/, '').trim());

      if (ingredients.length > 0) {
        sections.push({
          type: 'ingredients',
          heading,
          items: ingredients,
        });
      }
    }
  }

  return sections;
}

const parsedContent = parseRecipeContent(rawBody);
const ingredientSections = parsedContent.filter((s) => s.type === 'ingredients');
const stepsSections = parsedContent.filter((s) => s.type === 'steps');
---

<BaseLayout
  title={title}
  description={`${title} by ${author} - ${totalTime} minutes`}
  image={imagePath}
>
  {/* Back Button and Favorite */}
  <div class="max-w-5xl mx-auto px-4 py-4 flex items-center justify-between">
    <a
      href="/"
      class="inline-flex items-center gap-2 text-ctp-subtext1 hover:text-ctp-text transition-colors group"
    >
      <svg
        class="w-5 h-5 transition-transform group-hover:-translate-x-0.5"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
        stroke-width="2"
      >
        <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
      </svg>
      <span>Back to recipes</span>
    </a>

    <button
      type="button"
      class="favorite-btn p-2 rounded-full bg-ctp-surface0 border border-ctp-surface1 transition-all hover:bg-ctp-surface1 hover:scale-110"
      aria-label="Add to favorites"
      data-slug={slug}
    >
      <svg
        class="favorite-icon w-6 h-6 transition-colors"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
        stroke-width="2"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"
        />
      </svg>
    </button>
  </div>

  {/* Hero Image */}
  <div class="max-w-5xl mx-auto px-4 mb-8">
    <div class="relative aspect-[16/9] md:aspect-[21/9] rounded-2xl overflow-hidden bg-ctp-surface0">
      <img
        src={imagePath}
        alt={title}
        class="w-full h-full object-cover"
      />
    </div>
  </div>

  {/* Recipe Header */}
  <div class="max-w-5xl mx-auto px-4 mb-8">
    <h1 class="text-3xl md:text-4xl font-bold text-ctp-text mb-2">
      {title}
    </h1>
    <p class="text-ctp-subtext1 mb-4">by {author}</p>

    {/* Metadata badges */}
    <div class="flex flex-wrap gap-3 mb-4">
      {/* Prep time */}
      <div class="inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-ctp-surface0 text-ctp-subtext1 text-sm">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <span>Prep: {prep_time} min</span>
      </div>

      {/* Cook time */}
      <div class="inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-ctp-surface0 text-ctp-subtext1 text-sm">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z" />
          <path stroke-linecap="round" stroke-linejoin="round" d="M9.879 16.121A3 3 0 1012.015 11L11 14H9c0 .768.293 1.536.879 2.121z" />
        </svg>
        <span>Cook: {cook_time} min</span>
      </div>

      {/* Servings Scaler */}
      <ServingsScaler servings={servings} slug={slug} />
    </div>

    {/* Tags */}
    <div class="flex flex-wrap gap-2 mb-4">
      {tags.map((tag) => (
        <span class="px-3 py-1 text-sm font-medium rounded-full bg-ctp-green/20 text-ctp-green border border-ctp-green/30">
          {tag.replace(/-/g, ' ')}
        </span>
      ))}
    </div>

    {/* Source attribution */}
    {source && (
      <div class="text-sm text-ctp-subtext1">
        Source: {source.url ? (
          <a
            href={source.url}
            target="_blank"
            rel="noopener noreferrer"
            class="text-ctp-sapphire hover:underline inline-flex items-center gap-1"
          >
            {source.name}
            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
            </svg>
          </a>
        ) : (
          <span>{source.name}</span>
        )}
      </div>
    )}
  </div>

  {/* Main Content - Two columns on desktop */}
  <div class="max-w-5xl mx-auto px-4 mb-12">
    <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
      {/* Ingredients Column */}
      <div class="lg:col-span-4">
        <div class="lg:sticky lg:top-4">
          <div class="bg-ctp-surface0 rounded-2xl p-6 border border-ctp-surface1">
            <h2 class="text-xl font-semibold text-ctp-text mb-4 flex items-center gap-2">
              <svg class="w-5 h-5 text-ctp-peach" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
              </svg>
              Ingredients
            </h2>

            {ingredientSections.map((section, sectionIndex) => (
              <div class="mb-4 last:mb-0">
                {section.heading.toLowerCase() !== 'ingredients' && (
                  <h3 class="text-sm font-semibold text-ctp-subtext0 uppercase tracking-wide mb-2">
                    {section.heading}
                  </h3>
                )}
                <ul class="space-y-2 ingredient-list" data-section={sectionIndex}>
                  {section.items.map((ingredient, index) => (
                    <li class="flex items-start gap-3">
                      <input
                        type="checkbox"
                        id={`ingredient-${sectionIndex}-${index}`}
                        class="ingredient-checkbox mt-1 w-4 h-4 rounded border-ctp-surface2 bg-ctp-surface1 text-ctp-mauve focus:ring-ctp-mauve focus:ring-offset-0 cursor-pointer"
                        data-slug={slug}
                        data-section={sectionIndex}
                        data-index={index}
                      />
                      <label
                        for={`ingredient-${sectionIndex}-${index}`}
                        class="ingredient-label text-ctp-text cursor-pointer select-none"
                        data-original={ingredient}
                        set:html={ingredient.replace(/`([^`]+)`/g, '<strong class="scalable-amount text-ctp-peach" data-original="$1">$1</strong>')}
                      />
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Steps Column */}
      <div class="lg:col-span-8">
        <h2 class="text-xl font-semibold text-ctp-text mb-6 flex items-center gap-2">
          <svg class="w-5 h-5 text-ctp-mauve" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 10h16M4 14h16M4 18h16" />
          </svg>
          Steps
        </h2>

        <ol class="space-y-6">
          {stepsSections.flatMap((section) => section.items).map((step, index) => (
            <li class="flex gap-4">
              <div class="flex-shrink-0 w-8 h-8 rounded-full bg-ctp-mauve text-ctp-base flex items-center justify-center font-semibold text-sm">
                {index + 1}
              </div>
              <div class="flex-1 pt-1">
                <p class="text-ctp-text leading-relaxed">{step}</p>
              </div>
            </li>
          ))}
        </ol>
      </div>
    </div>
  </div>

  {/* Tips/Notes Section */}
  {notes && (
    <div class="max-w-5xl mx-auto px-4 mb-12">
      <div class="bg-ctp-yellow/10 border border-ctp-yellow/30 rounded-2xl p-6">
        <h2 class="text-lg font-semibold text-ctp-yellow mb-3 flex items-center gap-2">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
          </svg>
          Tips
        </h2>
        <div class="text-ctp-text prose prose-sm">
          {notes.split('\n').filter(Boolean).map((tip) => (
            <p class="mb-2 last:mb-0">{tip}</p>
          ))}
        </div>
      </div>
    </div>
  )}

  {/* Placeholder for future comments/ratings */}
  <div class="max-w-5xl mx-auto px-4 pb-12">
    <div class="border-t border-ctp-surface1 pt-8">
      <p class="text-center text-ctp-overlay0 text-sm">
        Comments and ratings coming soon...
      </p>
    </div>
  </div>
</BaseLayout>

<style>
  .favorite-btn .favorite-icon {
    @apply text-ctp-overlay0;
  }

  .favorite-btn:hover .favorite-icon {
    @apply text-ctp-red;
  }

  .favorite-btn.is-favorite .favorite-icon {
    @apply fill-ctp-red text-ctp-red;
  }

  .ingredient-checkbox:checked + .ingredient-label {
    @apply line-through text-ctp-overlay0;
  }

  /* Custom checkbox styling */
  .ingredient-checkbox {
    appearance: none;
    -webkit-appearance: none;
    border: 2px solid var(--ctp-surface2);
    background: var(--ctp-surface1);
  }

  .ingredient-checkbox:checked {
    background: var(--ctp-mauve);
    border-color: var(--ctp-mauve);
    background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e");
    background-size: 100% 100%;
    background-position: center;
    background-repeat: no-repeat;
  }
</style>

<script>
  // Initialize favorites from localStorage
  function initFavorites() {
    const favorites = JSON.parse(localStorage.getItem('favorites') || '[]') as string[];
    document.querySelectorAll('.favorite-btn').forEach((btn) => {
      const slug = (btn as HTMLElement).dataset.slug;
      if (slug && favorites.includes(slug)) {
        btn.classList.add('is-favorite');
        btn.setAttribute('aria-label', 'Remove from favorites');
      }
    });
  }

  // Toggle favorite status
  function toggleFavorite(slug: string, btn: HTMLElement) {
    const favorites = JSON.parse(localStorage.getItem('favorites') || '[]') as string[];
    const index = favorites.indexOf(slug);

    if (index === -1) {
      favorites.push(slug);
      btn.classList.add('is-favorite');
      btn.setAttribute('aria-label', 'Remove from favorites');
    } else {
      favorites.splice(index, 1);
      btn.classList.remove('is-favorite');
      btn.setAttribute('aria-label', 'Add to favorites');
    }

    localStorage.setItem('favorites', JSON.stringify(favorites));
  }

  // Initialize ingredient checkboxes from localStorage
  function initIngredientCheckboxes() {
    const checkboxes = document.querySelectorAll('.ingredient-checkbox') as NodeListOf<HTMLInputElement>;

    checkboxes.forEach((checkbox) => {
      const slug = checkbox.dataset.slug;
      const section = checkbox.dataset.section;
      const index = checkbox.dataset.index;

      if (slug && section !== undefined && index !== undefined) {
        const key = `ingredients-${slug}`;
        const checked = JSON.parse(localStorage.getItem(key) || '{}');
        const itemKey = `${section}-${index}`;

        if (checked[itemKey]) {
          checkbox.checked = true;
        }
      }
    });
  }

  // Save ingredient checkbox state to localStorage
  function saveIngredientState(slug: string, section: string, index: string, isChecked: boolean) {
    const key = `ingredients-${slug}`;
    const checked = JSON.parse(localStorage.getItem(key) || '{}');
    const itemKey = `${section}-${index}`;

    if (isChecked) {
      checked[itemKey] = true;
    } else {
      delete checked[itemKey];
    }

    localStorage.setItem(key, JSON.stringify(checked));
  }

  // Event delegation for favorite button
  document.addEventListener('click', (e) => {
    const btn = (e.target as HTMLElement).closest('.favorite-btn') as HTMLElement;
    if (btn) {
      e.preventDefault();
      const slug = btn.dataset.slug;
      if (slug) {
        toggleFavorite(slug, btn);
      }
    }
  });

  // Event delegation for ingredient checkboxes
  document.addEventListener('change', (e) => {
    const checkbox = e.target as HTMLInputElement;
    if (checkbox.classList.contains('ingredient-checkbox')) {
      const slug = checkbox.dataset.slug;
      const section = checkbox.dataset.section;
      const index = checkbox.dataset.index;

      if (slug && section !== undefined && index !== undefined) {
        saveIngredientState(slug, section, index, checkbox.checked);
      }
    }
  });

  // Initialize on page load
  initFavorites();
  initIngredientCheckboxes();

  // Re-initialize when navigating with View Transitions (if enabled)
  document.addEventListener('astro:page-load', () => {
    initFavorites();
    initIngredientCheckboxes();
  });

  // Ingredient scaling functionality
  function parseAmount(amountStr: string): { value: number; unit: string; original: string } | null {
    // Handle fractions like "1/2", "1 1/2", etc.
    const fractionPattern = /^(\d+)?\s*(\d+)\/(\d+)\s*(.*)$/;
    const fractionMatch = amountStr.match(fractionPattern);

    if (fractionMatch) {
      const whole = fractionMatch[1] ? parseInt(fractionMatch[1], 10) : 0;
      const numerator = parseInt(fractionMatch[2], 10);
      const denominator = parseInt(fractionMatch[3], 10);
      const unit = fractionMatch[4].trim();
      const value = whole + numerator / denominator;
      return { value, unit, original: amountStr };
    }

    // Handle simple numbers with optional decimal (e.g., "400g", "2.5 cups", "3 tbsp")
    const simplePattern = /^([\d.]+)\s*(.*)$/;
    const simpleMatch = amountStr.match(simplePattern);

    if (simpleMatch) {
      const value = parseFloat(simpleMatch[1]);
      const unit = simpleMatch[2].trim();
      if (!isNaN(value)) {
        return { value, unit, original: amountStr };
      }
    }

    return null;
  }

  function formatAmount(value: number, unit: string): string {
    // Round to a sensible precision
    let formatted: string;

    if (value === Math.floor(value)) {
      // Whole number
      formatted = String(Math.round(value));
    } else if (value < 1) {
      // Small fractions - check for common fractions
      const fractions: [number, string][] = [
        [0.25, '1/4'],
        [0.333, '1/3'],
        [0.5, '1/2'],
        [0.666, '2/3'],
        [0.75, '3/4'],
      ];
      const match = fractions.find(([frac]) => Math.abs(value - frac) < 0.05);
      if (match) {
        formatted = match[1];
      } else {
        formatted = value.toFixed(1).replace(/\.0$/, '');
      }
    } else {
      // Mixed numbers - check if fractional part is close to common fraction
      const whole = Math.floor(value);
      const frac = value - whole;

      if (frac < 0.1) {
        formatted = String(whole);
      } else if (Math.abs(frac - 0.25) < 0.05) {
        formatted = `${whole} 1/4`;
      } else if (Math.abs(frac - 0.333) < 0.05) {
        formatted = `${whole} 1/3`;
      } else if (Math.abs(frac - 0.5) < 0.05) {
        formatted = `${whole} 1/2`;
      } else if (Math.abs(frac - 0.666) < 0.05) {
        formatted = `${whole} 2/3`;
      } else if (Math.abs(frac - 0.75) < 0.05) {
        formatted = `${whole} 3/4`;
      } else if (frac > 0.9) {
        formatted = String(whole + 1);
      } else {
        formatted = value.toFixed(1).replace(/\.0$/, '');
      }
    }

    // Combine with unit (no space if unit starts with a letter attached to number, e.g., "400g")
    if (unit) {
      // If original had no space between number and unit (like "400g"), keep it that way
      return `${formatted}${unit}`;
    }
    return formatted;
  }

  function scaleIngredients(ratio: number) {
    document.querySelectorAll('.scalable-amount').forEach((el) => {
      const originalAmount = (el as HTMLElement).dataset.original;
      if (!originalAmount) return;

      const parsed = parseAmount(originalAmount);
      if (!parsed) {
        // Can't parse, just show original
        el.textContent = originalAmount;
        return;
      }

      const scaledValue = parsed.value * ratio;
      el.textContent = formatAmount(scaledValue, parsed.unit);
    });
  }

  // Listen for servings change events
  document.addEventListener('servingschange', ((e: CustomEvent) => {
    const { ratio } = e.detail;
    scaleIngredients(ratio);
  }) as EventListener);
</script>
